import * as t from '@babel/types';
export declare const commentBlock: (value: string) => t.CommentBlock;
export declare const commentLine: (value: string) => t.CommentLine;
export declare function tsMethodSignature(key: t.Expression, typeParameters: t.TSTypeParameterDeclaration | null | undefined, parameters: Array<t.Identifier | t.RestElement>, typeAnnotation?: t.TSTypeAnnotation | null, trailingComments?: t.Comment[], leadingComments?: t.Comment[]): t.TSMethodSignature;
export declare const classMethod: (kind: "get" | "set" | "method" | "constructor" | undefined, key: t.Identifier | t.StringLiteral | t.NumericLiteral | t.Expression, params: Array<t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty>, body: t.BlockStatement, returnType?: t.TSTypeAnnotation, leadingComments?: t.CommentLine[] | t.CommentBlock[], computed?: boolean, _static?: boolean, generator?: boolean, async?: boolean) => t.ClassMethod;
export declare const tsEnumMember: (id: t.Identifier | t.StringLiteral, initializer?: t.Expression, leadingComments?: any[]) => t.TSEnumMember;
export declare const tsPropertySignature: (key: t.Expression, typeAnnotation: t.TSTypeAnnotation, optional: boolean) => t.TSPropertySignature;
export declare const functionDeclaration: (id: t.Identifier, params: (t.Identifier | t.Pattern | t.RestElement)[], body: t.BlockStatement, generator?: boolean, async?: boolean, returnType?: t.TSTypeAnnotation) => t.FunctionDeclaration;
export declare const callExpression: (callee: t.Expression | t.V8IntrinsicIdentifier, _arguments: (t.Expression | t.SpreadElement | t.ArgumentPlaceholder)[], typeParameters: t.TSTypeParameterInstantiation) => t.CallExpression;
export declare const identifier: (name: string, typeAnnotation: t.TSTypeAnnotation, optional?: boolean) => t.Identifier;
export declare const classDeclaration: (id: t.Identifier, superClass: t.Expression | null | undefined, body: t.ClassBody, decorators?: Array<t.Decorator> | null, vImplements?: t.TSExpressionWithTypeArguments[]) => t.ClassDeclaration;
export declare function classProperty(key: t.Identifier | t.StringLiteral | t.NumericLiteral | t.Expression, value?: t.Expression | null, typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null, decorators?: Array<t.Decorator> | null, computed?: boolean, _static?: boolean, _readonly?: boolean, accessibility?: 'private' | 'protected' | 'public', leadingComments?: t.CommentLine[]): t.ClassProperty;
export declare const arrowFunctionExpression: (params: (t.Identifier | t.Pattern | t.RestElement)[], body: t.BlockStatement, returnType?: t.TSTypeAnnotation, isAsync?: boolean, typeParameters?: t.TypeParameterDeclaration | t.TSTypeParameterDeclaration | t.Noop) => t.ArrowFunctionExpression;
export declare const tsTypeParameterDeclaration: (params: Array<t.TSTypeParameter>) => t.TSTypeParameterDeclaration;
export declare const objectPattern: (properties: (t.RestElement | t.ObjectProperty)[], typeAnnotation: t.TSTypeAnnotation) => t.ObjectPattern;
export declare const objectMethod: (kind: "method" | "get" | "set", key: t.Expression, params: (t.Identifier | t.Pattern | t.RestElement)[], body: t.BlockStatement, computed?: boolean, generator?: boolean, async?: boolean, returnType?: t.TSTypeAnnotation | t.TypeAnnotation | t.Noop, typeParameters?: t.TypeParameterDeclaration | t.TSTypeParameterDeclaration | t.Noop) => t.ObjectMethod;
export declare const objectProperty: (key: t.Expression | t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral | t.DecimalLiteral | t.PrivateName, value: t.Expression | t.PatternLike, computed?: boolean, shorthand?: boolean, decorators?: Array<t.Decorator> | null, leadingComments?: t.CommentLine[]) => t.ObjectProperty;
export declare const makeCommentLineWithBlocks: (comment: string) => t.CommentLine[];
