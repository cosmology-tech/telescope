import * as t from "@babel/types";
import { fromAminoMethod } from "./index";
import { ProtoType } from "@cosmology/types";
import { ProtoParseContext } from "../../context";
export declare const fromAmino: {
    string(args: fromAminoMethod): t.Statement;
    bool(args: fromAminoMethod): t.Statement;
    number(args: fromAminoMethod): t.Statement;
    int32(args: fromAminoMethod): t.Statement;
    uint32(args: fromAminoMethod): t.Statement;
    sint32(args: fromAminoMethod): t.Statement;
    fixed32(args: fromAminoMethod): t.Statement;
    sfixed32(args: fromAminoMethod): t.Statement;
    double(args: fromAminoMethod): t.Statement;
    float(args: fromAminoMethod): t.Statement;
    long(args: fromAminoMethod): t.Statement;
    int64(args: fromAminoMethod): t.Statement;
    uint64(args: fromAminoMethod): t.Statement;
    sint64(args: fromAminoMethod): t.Statement;
    fixed64(args: fromAminoMethod): t.Statement;
    sfixed64(args: fromAminoMethod): t.Statement;
    protoType(args: fromAminoMethod): t.Statement;
    anyType(args: fromAminoMethod): t.Statement;
    type(args: fromAminoMethod): t.Statement;
    enum(args: fromAminoMethod): t.Statement;
    bytes(args: fromAminoMethod): t.Statement;
    duration(args: fromAminoMethod): t.Statement;
    durationString(args: fromAminoMethod): t.Statement;
    timestamp(args: fromAminoMethod): t.Statement;
    timestampDate(args: fromAminoMethod): t.Statement;
    keyHash(args: fromAminoMethod): t.ExpressionStatement;
    array(args: fromAminoMethod, expr: t.Expression): t.ExpressionStatement;
    pubkey(args: fromAminoMethod): t.Statement;
    rawBytes(args: fromAminoMethod): t.Statement;
    wasmByteCode(args: fromAminoMethod): t.Statement;
};
export declare const arrayTypes: {
    identity(): t.Identifier;
    string(): t.Identifier;
    bool(): t.Identifier;
    rawBytes(args: fromAminoMethod): t.CallExpression;
    wasmByteCode(args: fromAminoMethod): t.CallExpression;
    bytes(args: fromAminoMethod): t.CallExpression;
    double(): t.Identifier;
    float(): t.Identifier;
    int32(): t.Identifier;
    uint32(): t.Identifier;
    sint32(): t.Identifier;
    fixed32(): t.Identifier;
    sfixed32(): t.Identifier;
    enum(): t.Identifier;
    long(args: fromAminoMethod): t.Expression;
    int64(args: fromAminoMethod): t.Expression;
    uint64(args: fromAminoMethod): t.Expression;
    sint64(args: fromAminoMethod): t.Expression;
    fixed64(args: fromAminoMethod): t.Expression;
    sfixed64(args: fromAminoMethod): t.Expression;
    anyType(args: fromAminoMethod): t.CallExpression;
    protoType(args: fromAminoMethod): t.CallExpression;
    type(args: fromAminoMethod): t.CallExpression;
};
export declare const fromAminoMessages: {
    anyType(): t.ReturnStatement[];
    timestamp(context: ProtoParseContext, name: string, proto: ProtoType): t.ReturnStatement[];
    height(context: ProtoParseContext, name: string, proto: ProtoType): t.ReturnStatement[];
    duration(context: ProtoParseContext, name: string, proto: ProtoType): (t.VariableDeclaration | t.ReturnStatement)[];
};
