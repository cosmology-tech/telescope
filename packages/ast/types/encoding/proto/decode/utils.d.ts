import * as t from '@babel/types';
import { DecodeMethod } from './index';
export declare const decode: {
    string(args: DecodeMethod): t.SwitchCase;
    bool(args: DecodeMethod): t.SwitchCase;
    double(args: DecodeMethod): t.SwitchCase;
    float(args: DecodeMethod): t.SwitchCase;
    int32(args: DecodeMethod): t.SwitchCase;
    sint32(args: DecodeMethod): t.SwitchCase;
    uint32(args: DecodeMethod): t.SwitchCase;
    fixed32(args: DecodeMethod): t.SwitchCase;
    sfixed32(args: DecodeMethod): t.SwitchCase;
    int64(args: DecodeMethod): t.SwitchCase;
    sint64(args: DecodeMethod): t.SwitchCase;
    uint64(args: DecodeMethod): t.SwitchCase;
    fixed64(args: DecodeMethod): t.SwitchCase;
    sfixed64(args: DecodeMethod): t.SwitchCase;
    duration(args: DecodeMethod): t.SwitchCase;
    timestamp(args: DecodeMethod): t.SwitchCase;
    type(args: DecodeMethod): t.SwitchCase;
    enum(args: DecodeMethod): t.SwitchCase;
    bytes(args: DecodeMethod): t.SwitchCase;
    keyHash(args: DecodeMethod): t.SwitchCase;
    tagDelimArray(args: DecodeMethod, expr: t.Expression): t.SwitchCase;
    array(args: DecodeMethod, expr: t.Expression): t.SwitchCase;
    typeArray(args: DecodeMethod): t.SwitchCase;
};
export declare const baseTypes: {
    string(args: DecodeMethod): t.CallExpression;
    bool(args: DecodeMethod): t.CallExpression;
    double(args: DecodeMethod): t.CallExpression;
    float(args: DecodeMethod): t.CallExpression;
    int32(args: DecodeMethod): t.CallExpression;
    sint32(args: DecodeMethod): t.CallExpression;
    uint32(args: DecodeMethod): t.CallExpression;
    fixed32(args: DecodeMethod): t.CallExpression;
    sfixed32(args: DecodeMethod): t.CallExpression;
    long(type: string, args: DecodeMethod): t.CallExpression | t.TSAsExpression;
    int64(args: DecodeMethod): t.CallExpression | t.TSAsExpression;
    sint64(args: DecodeMethod): t.CallExpression | t.TSAsExpression;
    uint64(args: DecodeMethod): t.CallExpression | t.TSAsExpression;
    fixed64(args: DecodeMethod): t.CallExpression | t.TSAsExpression;
    sfixed64(args: DecodeMethod): t.CallExpression | t.TSAsExpression;
    protoType(args: DecodeMethod): t.CallExpression;
    anyType(args: DecodeMethod): t.ConditionalExpression;
    type(args: DecodeMethod): t.CallExpression | t.ConditionalExpression;
    enum(args: DecodeMethod): t.TSAsExpression;
    bytes(args: DecodeMethod): t.CallExpression;
    durationString(args: DecodeMethod): t.CallExpression;
    timestamp(args: DecodeMethod): t.CallExpression;
    timestampDate(args: DecodeMethod): t.CallExpression;
    keyHash(args: DecodeMethod): (t.VariableDeclaration | t.IfStatement)[];
};
export declare const switchOnTag: (num: number, prop: string, expr: t.Expression) => t.SwitchCase;
export declare const switchOnTagTakesArray: (num: number, prop: string, expr: t.Statement[]) => t.SwitchCase;
export declare const switchProtoTypeArray: (args: DecodeMethod, num: number, prop: string, name: string) => t.SwitchCase;
export declare const switchAnyTypeArray: (num: number, prop: string, typeName: string, interfaceName: string) => t.SwitchCase;
export declare const switchTagDelimArray: (num: number, prop: string, expr: t.Expression) => t.SwitchCase;
export declare const switchArray: (num: number, prop: string, expr: t.Expression) => t.SwitchCase;
