import * as t from '@babel/types';
export declare const tsEnumMember: (id: t.Identifier | t.StringLiteral, initializer?: t.Expression, leadingComments?: any[]) => t.TSEnumMember;
export declare const tsPropertySignature: (key: t.Expression, typeAnnotation: t.TSTypeAnnotation, optional: boolean) => t.TSPropertySignature;
export declare const functionDeclaration: (id: t.Identifier, params: (t.Identifier | t.Pattern | t.RestElement)[], body: t.BlockStatement, generator?: boolean, async?: boolean, returnType?: t.TSTypeAnnotation) => t.FunctionDeclaration;
export declare const callExpression: (callee: t.Expression | t.V8IntrinsicIdentifier, _arguments: (t.Expression | t.SpreadElement | t.ArgumentPlaceholder)[], typeParameters: t.TSTypeParameterInstantiation) => t.CallExpression;
export declare const identifier: (name: string, typeAnnotation: t.TSTypeAnnotation, optional?: boolean) => t.Identifier;
export declare const classDeclaration: (name: string, body: any[], implementsExressions?: t.TSExpressionWithTypeArguments[], superClass?: t.Identifier) => t.ClassDeclaration;
export declare const classProperty: (name: string, typeAnnotation?: t.TSTypeAnnotation, isReadonly?: boolean, isStatic?: boolean) => t.ClassProperty;
export declare const arrowFunctionExpression: (params: (t.Identifier | t.Pattern | t.RestElement)[], body: t.BlockStatement, returnType: t.TSTypeAnnotation, isAsync?: boolean) => t.ArrowFunctionExpression;
export declare const objectPattern: (properties: (t.RestElement | t.ObjectProperty)[], typeAnnotation: t.TSTypeAnnotation) => t.ObjectPattern;
export declare const objectMethod: (kind: "method" | "get" | "set", key: t.Expression, params: (t.Identifier | t.Pattern | t.RestElement)[], body: t.BlockStatement, computed?: boolean, generator?: boolean, async?: boolean, returnType?: t.TSTypeAnnotation | t.TypeAnnotation | t.Noop, typeParameters?: t.TypeParameterDeclaration | t.TSTypeParameterDeclaration | t.Noop) => t.ObjectMethod;
