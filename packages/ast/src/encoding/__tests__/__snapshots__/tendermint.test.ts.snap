// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ibc/lightclients/tendermint/v1/tendermint duration 1`] = `
"/**
 * ClientState from Tendermint tracks the current validator set, latest height,
 * and a possible frozen height.
 */
export interface ClientState {
  chainId: string;
  trustLevel?: Fraction;

  /**
   * duration of the period since the LastestTimestamp during which the
   * submitted headers are valid for upgrade
   */
  trustingPeriod?: Duration;

  /** duration of the staking unbonding period */
  unbondingPeriod?: Duration;

  /** defines how much new (untrusted) header's Time can drift into the future. */
  maxClockDrift?: Duration;

  /** Block height when the client was frozen due to a misbehaviour */
  frozenHeight?: Height;

  /** Latest height the client was updated to */
  latestHeight?: Height;

  /** Proof specifications used in verifying counterparty state */
  proofSpecs: ProofSpec[];

  /**
   * Path at which next upgraded client will be committed.
   * Each element corresponds to the key for a single CommitmentProof in the
   * chained proof. NOTE: ClientState must stored under
   * \`{upgradePath}/{upgradeHeight}/clientState\` ConsensusState must be stored
   * under \`{upgradepath}/{upgradeHeight}/consensusState\` For SDK chains using
   * the default upgrade module, upgrade_path should be []string{"upgrade",
   * "upgradedIBCState"}\`
   */
  upgradePath: string[];

  /**
   * This flag, when set to true, will allow governance to recover a client
   * which has expired
   */
  allowUpdateAfterExpiry: boolean;

  /**
   * This flag, when set to true, will allow governance to unfreeze a client
   * whose chain has experienced a misbehaviour event
   */
  allowUpdateAfterMisbehaviour: boolean;
}"
`;

exports[`ibc/lightclients/tendermint/v1/tendermint duration 2`] = `
"export const ClientState = {
  encode(message: ClientState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }

    if (message.trustLevel !== undefined) {
      Fraction.encode(message.trustLevel, writer.uint32(18).fork()).ldelim();
    }

    if (message.trustingPeriod !== undefined) {
      Duration.encode(message.trustingPeriod, writer.uint32(26).fork()).ldelim();
    }

    if (message.unbondingPeriod !== undefined) {
      Duration.encode(message.unbondingPeriod, writer.uint32(34).fork()).ldelim();
    }

    if (message.maxClockDrift !== undefined) {
      Duration.encode(message.maxClockDrift, writer.uint32(42).fork()).ldelim();
    }

    if (message.frozenHeight !== undefined) {
      Height.encode(message.frozenHeight, writer.uint32(50).fork()).ldelim();
    }

    if (message.latestHeight !== undefined) {
      Height.encode(message.latestHeight, writer.uint32(58).fork()).ldelim();
    }

    for (const v of message.proofSpecs) {
      ProofSpec.encode(v!, writer.uint32(66).fork()).ldelim();
    }

    for (const v of message.upgradePath) {
      writer.uint32(74).string(v!);
    }

    if (message.allowUpdateAfterExpiry === true) {
      writer.uint32(80).bool(message.allowUpdateAfterExpiry);
    }

    if (message.allowUpdateAfterMisbehaviour === true) {
      writer.uint32(88).bool(message.allowUpdateAfterMisbehaviour);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientState();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.chainId = reader.string();
          break;

        case 2:
          message.trustLevel = Fraction.decode(reader, reader.uint32());
          break;

        case 3:
          message.trustingPeriod = Duration.decode(reader, reader.uint32());
          break;

        case 4:
          message.unbondingPeriod = Duration.decode(reader, reader.uint32());
          break;

        case 5:
          message.maxClockDrift = Duration.decode(reader, reader.uint32());
          break;

        case 6:
          message.frozenHeight = Height.decode(reader, reader.uint32());
          break;

        case 7:
          message.latestHeight = Height.decode(reader, reader.uint32());
          break;

        case 8:
          message.proofSpecs.push(ProofSpec.decode(reader, reader.uint32()));
          break;

        case 9:
          message.upgradePath.push(reader.string());
          break;

        case 10:
          message.allowUpdateAfterExpiry = reader.bool();
          break;

        case 11:
          message.allowUpdateAfterMisbehaviour = reader.bool();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): ClientState {
    return {
      chainId: isSet(object.chainId) ? String(object.chainId) : "",
      trustLevel: isSet(object.trustLevel) ? Fraction.fromJSON(object.trustLevel) : undefined,
      trustingPeriod: isSet(object.trustingPeriod) ? Duration.fromJSON(object.trustingPeriod) : undefined,
      unbondingPeriod: isSet(object.unbondingPeriod) ? Duration.fromJSON(object.unbondingPeriod) : undefined,
      maxClockDrift: isSet(object.maxClockDrift) ? Duration.fromJSON(object.maxClockDrift) : undefined,
      frozenHeight: isSet(object.frozenHeight) ? Height.fromJSON(object.frozenHeight) : undefined,
      latestHeight: isSet(object.latestHeight) ? Height.fromJSON(object.latestHeight) : undefined,
      proofSpecs: Array.isArray(object?.proofSpecs) ? object.proofSpecs.map((e: any) => ProofSpec.fromJSON(e)) : [],
      upgradePath: Array.isArray(object?.upgradePath) ? object.upgradePath.map((e: any) => String(e)) : [],
      allowUpdateAfterExpiry: isSet(object.allowUpdateAfterExpiry) ? Boolean(object.allowUpdateAfterExpiry) : false,
      allowUpdateAfterMisbehaviour: isSet(object.allowUpdateAfterMisbehaviour) ? Boolean(object.allowUpdateAfterMisbehaviour) : false
    };
  },

  toJSON(message: ClientState): unknown {
    const obj: any = {};
    message.chainId !== undefined && (obj.chainId = message.chainId);
    message.trustLevel !== undefined && (obj.trustLevel = message.trustLevel ? Fraction.toJSON(message.trustLevel) : undefined);
    message.trustingPeriod !== undefined && (obj.trustingPeriod = message.trustingPeriod ? Duration.toJSON(message.trustingPeriod) : undefined);
    message.unbondingPeriod !== undefined && (obj.unbondingPeriod = message.unbondingPeriod ? Duration.toJSON(message.unbondingPeriod) : undefined);
    message.maxClockDrift !== undefined && (obj.maxClockDrift = message.maxClockDrift ? Duration.toJSON(message.maxClockDrift) : undefined);
    message.frozenHeight !== undefined && (obj.frozenHeight = message.frozenHeight ? Height.toJSON(message.frozenHeight) : undefined);
    message.latestHeight !== undefined && (obj.latestHeight = message.latestHeight ? Height.toJSON(message.latestHeight) : undefined);

    if (message.proofSpecs) {
      obj.proofSpecs = message.proofSpecs.map(e => e ? ProofSpec.toJSON(e) : undefined);
    } else {
      obj.proofSpecs = [];
    }

    if (message.upgradePath) {
      obj.upgradePath = message.upgradePath.map(e => e);
    } else {
      obj.upgradePath = [];
    }

    message.allowUpdateAfterExpiry !== undefined && (obj.allowUpdateAfterExpiry = message.allowUpdateAfterExpiry);
    message.allowUpdateAfterMisbehaviour !== undefined && (obj.allowUpdateAfterMisbehaviour = message.allowUpdateAfterMisbehaviour);
    return obj;
  },

  fromPartial(object: DeepPartial<ClientState>): ClientState {
    const message = createBaseClientState();
    message.chainId = object.chainId ?? "";
    message.trustLevel = object.trustLevel !== undefined && object.trustLevel !== null ? Fraction.fromPartial(object.trustLevel) : undefined;
    message.trustingPeriod = object.trustingPeriod !== undefined && object.trustingPeriod !== null ? Duration.fromPartial(object.trustingPeriod) : undefined;
    message.unbondingPeriod = object.unbondingPeriod !== undefined && object.unbondingPeriod !== null ? Duration.fromPartial(object.unbondingPeriod) : undefined;
    message.maxClockDrift = object.maxClockDrift !== undefined && object.maxClockDrift !== null ? Duration.fromPartial(object.maxClockDrift) : undefined;
    message.frozenHeight = object.frozenHeight !== undefined && object.frozenHeight !== null ? Height.fromPartial(object.frozenHeight) : undefined;
    message.latestHeight = object.latestHeight !== undefined && object.latestHeight !== null ? Height.fromPartial(object.latestHeight) : undefined;
    message.proofSpecs = object.proofSpecs?.map(e => ProofSpec.fromPartial(e)) || [];
    message.upgradePath = object.upgradePath?.map(e => e) || [];
    message.allowUpdateAfterExpiry = object.allowUpdateAfterExpiry ?? false;
    message.allowUpdateAfterMisbehaviour = object.allowUpdateAfterMisbehaviour ?? false;
    return message;
  },

  fromSDK(object: ClientStateSDKType): ClientState {
    return {
      chainId: object?.chain_id,
      trustLevel: object.trust_level ? Fraction.fromSDK(object.trust_level) : undefined,
      trustingPeriod: object.trusting_period ? Duration.fromSDK(object.trusting_period) : undefined,
      unbondingPeriod: object.unbonding_period ? Duration.fromSDK(object.unbonding_period) : undefined,
      maxClockDrift: object.max_clock_drift ? Duration.fromSDK(object.max_clock_drift) : undefined,
      frozenHeight: object.frozen_height ? Height.fromSDK(object.frozen_height) : undefined,
      latestHeight: object.latest_height ? Height.fromSDK(object.latest_height) : undefined,
      proofSpecs: Array.isArray(object?.proof_specs) ? object.proof_specs.map((e: any) => ProofSpec.fromSDK(e)) : [],
      upgradePath: Array.isArray(object?.upgrade_path) ? object.upgrade_path.map((e: any) => e) : [],
      allowUpdateAfterExpiry: object?.allow_update_after_expiry,
      allowUpdateAfterMisbehaviour: object?.allow_update_after_misbehaviour
    };
  },

  toSDK(message: ClientState): ClientStateSDKType {
    const obj: any = {};
    obj.chain_id = message.chainId;
    message.trustLevel !== undefined && (obj.trust_level = message.trustLevel ? Fraction.toSDK(message.trustLevel) : undefined);
    message.trustingPeriod !== undefined && (obj.trusting_period = message.trustingPeriod ? Duration.toSDK(message.trustingPeriod) : undefined);
    message.unbondingPeriod !== undefined && (obj.unbonding_period = message.unbondingPeriod ? Duration.toSDK(message.unbondingPeriod) : undefined);
    message.maxClockDrift !== undefined && (obj.max_clock_drift = message.maxClockDrift ? Duration.toSDK(message.maxClockDrift) : undefined);
    message.frozenHeight !== undefined && (obj.frozen_height = message.frozenHeight ? Height.toSDK(message.frozenHeight) : undefined);
    message.latestHeight !== undefined && (obj.latest_height = message.latestHeight ? Height.toSDK(message.latestHeight) : undefined);

    if (message.proofSpecs) {
      obj.proof_specs = message.proofSpecs.map(e => e ? ProofSpec.toSDK(e) : undefined);
    } else {
      obj.proof_specs = [];
    }

    if (message.upgradePath) {
      obj.upgrade_path = message.upgradePath.map(e => e);
    } else {
      obj.upgrade_path = [];
    }

    obj.allow_update_after_expiry = message.allowUpdateAfterExpiry;
    obj.allow_update_after_misbehaviour = message.allowUpdateAfterMisbehaviour;
    return obj;
  }

};"
`;

exports[`ibc/lightclients/tendermint/v1/tendermint duration 3`] = `
"export interface ClientStateAminoType extends AminoMsg {
  type: "cosmos-sdk/ClientState";
  value: {
    chain_id: string;
    trust_level: {
      numerator: string;
      denominator: string;
    };
    trusting_period: {
      seconds: string;
      nanos: number;
    };
    unbonding_period: {
      seconds: string;
      nanos: number;
    };
    max_clock_drift: {
      seconds: string;
      nanos: number;
    };
    frozen_height: AminoHeight;
    latest_height: AminoHeight;
    proof_specs: {
      leaf_spec: {
        hash: number;
        prehash_key: number;
        prehash_value: number;
        length: number;
        prefix: Uint8Array;
      };
      inner_spec: {
        child_order: number[];
        child_size: number;
        min_prefix_length: number;
        max_prefix_length: number;
        empty_child: Uint8Array;
        hash: number;
      };
      max_depth: number;
      min_depth: number;
    }[];
    upgrade_path: string[];
    allow_update_after_expiry: boolean;
    allow_update_after_misbehaviour: boolean;
  };
}"
`;

exports[`ibc/lightclients/tendermint/v1/tendermint duration 4`] = `
"export const AminoConverter = {
  "/ibc.lightclients.tendermint.v1.ClientState": {
    aminoType: "cosmos-sdk/ClientState",
    toAmino: ({
      chainId,
      trustLevel,
      trustingPeriod,
      unbondingPeriod,
      maxClockDrift,
      frozenHeight,
      latestHeight,
      proofSpecs,
      upgradePath,
      allowUpdateAfterExpiry,
      allowUpdateAfterMisbehaviour
    }: ClientState): ClientStateAminoType["value"] => {
      return {
        chain_id: chainId,
        trust_level: {
          numerator: trustLevel.numerator.toString(),
          denominator: trustLevel.denominator.toString()
        },
        trusting_period: (trustingPeriod * 1_000_000_000).toString(),
        unbonding_period: (unbondingPeriod * 1_000_000_000).toString(),
        max_clock_drift: (maxClockDrift * 1_000_000_000).toString(),
        frozen_height: frozenHeight ? {
          revision_height: omitDefault(frozenHeight.revisionHeight)?.toString(),
          revision_number: omitDefault(frozenHeight.revisionNumber)?.toString()
        } : {},
        latest_height: latestHeight ? {
          revision_height: omitDefault(latestHeight.revisionHeight)?.toString(),
          revision_number: omitDefault(latestHeight.revisionNumber)?.toString()
        } : {},
        proof_specs: proofSpecs.map(el0 => ({
          leaf_spec: {
            hash: el0.leafSpec.hash,
            prehash_key: el0.leafSpec.prehashKey,
            prehash_value: el0.leafSpec.prehashValue,
            length: el0.leafSpec.length,
            prefix: el0.leafSpec.prefix
          },
          inner_spec: {
            child_order: el0.innerSpec.childOrder,
            child_size: el0.innerSpec.childSize,
            min_prefix_length: el0.innerSpec.minPrefixLength,
            max_prefix_length: el0.innerSpec.maxPrefixLength,
            empty_child: el0.innerSpec.emptyChild,
            hash: el0.innerSpec.hash
          },
          max_depth: el0.maxDepth,
          min_depth: el0.minDepth
        })),
        upgrade_path: upgradePath,
        allow_update_after_expiry: allowUpdateAfterExpiry,
        allow_update_after_misbehaviour: allowUpdateAfterMisbehaviour
      };
    },
    fromAmino: ({
      chain_id,
      trust_level,
      trusting_period,
      unbonding_period,
      max_clock_drift,
      frozen_height,
      latest_height,
      proof_specs,
      upgrade_path,
      allow_update_after_expiry,
      allow_update_after_misbehaviour
    }: ClientStateAminoType["value"]): ClientState => {
      return {
        chainId: chain_id,
        trustLevel: {
          numerator: Long.fromString(trust_level.numerator),
          denominator: Long.fromString(trust_level.denominator)
        },
        trustingPeriod: {
          seconds: Long.fromNumber(Math.floor(parseInt(trusting_period) / 1_000_000_000)),
          nanos: parseInt(trusting_period) % 1_000_000_000
        },
        unbondingPeriod: {
          seconds: Long.fromNumber(Math.floor(parseInt(unbonding_period) / 1_000_000_000)),
          nanos: parseInt(unbonding_period) % 1_000_000_000
        },
        maxClockDrift: {
          seconds: Long.fromNumber(Math.floor(parseInt(max_clock_drift) / 1_000_000_000)),
          nanos: parseInt(max_clock_drift) % 1_000_000_000
        },
        frozenHeight: frozen_height ? {
          revisionHeight: Long.fromString(frozen_height.revision_height || "0", true),
          revisionNumber: Long.fromString(frozen_height.revision_number || "0", true)
        } : undefined,
        latestHeight: latest_height ? {
          revisionHeight: Long.fromString(latest_height.revision_height || "0", true),
          revisionNumber: Long.fromString(latest_height.revision_number || "0", true)
        } : undefined,
        proofSpecs: proof_specs.map(el0 => ({
          leafSpec: {
            hash: hashOpFromJSON(el0.leaf_spec.hash),
            prehashKey: hashOpFromJSON(el0.leaf_spec.prehash_key),
            prehashValue: hashOpFromJSON(el0.leaf_spec.prehash_value),
            length: lengthOpFromJSON(el0.leaf_spec.length),
            prefix: el0.leaf_spec.prefix
          },
          innerSpec: {
            childOrder: el0.inner_spec.child_order,
            childSize: el0.inner_spec.child_size,
            minPrefixLength: el0.inner_spec.min_prefix_length,
            maxPrefixLength: el0.inner_spec.max_prefix_length,
            emptyChild: el0.inner_spec.empty_child,
            hash: hashOpFromJSON(el0.inner_spec.hash)
          },
          maxDepth: el0.max_depth,
          minDepth: el0.min_depth
        })),
        upgradePath: upgrade_path,
        allowUpdateAfterExpiry: allow_update_after_expiry,
        allowUpdateAfterMisbehaviour: allow_update_after_misbehaviour
      };
    }
  }
};"
`;

exports[`ibc/lightclients/tendermint/v1/tendermint string 1`] = `
"/**
 * ClientState from Tendermint tracks the current validator set, latest height,
 * and a possible frozen height.
 */
export interface ClientState {
  chainId: string;
  trustLevel?: Fraction;

  /**
   * duration of the period since the LastestTimestamp during which the
   * submitted headers are valid for upgrade
   */
  trustingPeriod?: string;

  /** duration of the staking unbonding period */
  unbondingPeriod?: string;

  /** defines how much new (untrusted) header's Time can drift into the future. */
  maxClockDrift?: string;

  /** Block height when the client was frozen due to a misbehaviour */
  frozenHeight?: Height;

  /** Latest height the client was updated to */
  latestHeight?: Height;

  /** Proof specifications used in verifying counterparty state */
  proofSpecs: ProofSpec[];

  /**
   * Path at which next upgraded client will be committed.
   * Each element corresponds to the key for a single CommitmentProof in the
   * chained proof. NOTE: ClientState must stored under
   * \`{upgradePath}/{upgradeHeight}/clientState\` ConsensusState must be stored
   * under \`{upgradepath}/{upgradeHeight}/consensusState\` For SDK chains using
   * the default upgrade module, upgrade_path should be []string{"upgrade",
   * "upgradedIBCState"}\`
   */
  upgradePath: string[];

  /**
   * This flag, when set to true, will allow governance to recover a client
   * which has expired
   */
  allowUpdateAfterExpiry: boolean;

  /**
   * This flag, when set to true, will allow governance to unfreeze a client
   * whose chain has experienced a misbehaviour event
   */
  allowUpdateAfterMisbehaviour: boolean;
}"
`;

exports[`ibc/lightclients/tendermint/v1/tendermint string 2`] = `
"export const ClientState = {
  encode(message: ClientState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }

    if (message.trustLevel !== undefined) {
      Fraction.encode(message.trustLevel, writer.uint32(18).fork()).ldelim();
    }

    if (message.trustingPeriod !== undefined) {
      Duration.encode(toDuration(message.trustingPeriod), writer.uint32(26).fork()).ldelim();
    }

    if (message.unbondingPeriod !== undefined) {
      Duration.encode(toDuration(message.unbondingPeriod), writer.uint32(34).fork()).ldelim();
    }

    if (message.maxClockDrift !== undefined) {
      Duration.encode(toDuration(message.maxClockDrift), writer.uint32(42).fork()).ldelim();
    }

    if (message.frozenHeight !== undefined) {
      Height.encode(message.frozenHeight, writer.uint32(50).fork()).ldelim();
    }

    if (message.latestHeight !== undefined) {
      Height.encode(message.latestHeight, writer.uint32(58).fork()).ldelim();
    }

    for (const v of message.proofSpecs) {
      ProofSpec.encode(v!, writer.uint32(66).fork()).ldelim();
    }

    for (const v of message.upgradePath) {
      writer.uint32(74).string(v!);
    }

    if (message.allowUpdateAfterExpiry === true) {
      writer.uint32(80).bool(message.allowUpdateAfterExpiry);
    }

    if (message.allowUpdateAfterMisbehaviour === true) {
      writer.uint32(88).bool(message.allowUpdateAfterMisbehaviour);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientState();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.chainId = reader.string();
          break;

        case 2:
          message.trustLevel = Fraction.decode(reader, reader.uint32());
          break;

        case 3:
          message.trustingPeriod = fromDuration(Duration.decode(reader, reader.uint32()));
          break;

        case 4:
          message.unbondingPeriod = fromDuration(Duration.decode(reader, reader.uint32()));
          break;

        case 5:
          message.maxClockDrift = fromDuration(Duration.decode(reader, reader.uint32()));
          break;

        case 6:
          message.frozenHeight = Height.decode(reader, reader.uint32());
          break;

        case 7:
          message.latestHeight = Height.decode(reader, reader.uint32());
          break;

        case 8:
          message.proofSpecs.push(ProofSpec.decode(reader, reader.uint32()));
          break;

        case 9:
          message.upgradePath.push(reader.string());
          break;

        case 10:
          message.allowUpdateAfterExpiry = reader.bool();
          break;

        case 11:
          message.allowUpdateAfterMisbehaviour = reader.bool();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): ClientState {
    return {
      chainId: isSet(object.chainId) ? String(object.chainId) : "",
      trustLevel: isSet(object.trustLevel) ? Fraction.fromJSON(object.trustLevel) : undefined,
      trustingPeriod: isSet(object.trustingPeriod) ? String(object.trustingPeriod) : undefined,
      unbondingPeriod: isSet(object.unbondingPeriod) ? String(object.unbondingPeriod) : undefined,
      maxClockDrift: isSet(object.maxClockDrift) ? String(object.maxClockDrift) : undefined,
      frozenHeight: isSet(object.frozenHeight) ? Height.fromJSON(object.frozenHeight) : undefined,
      latestHeight: isSet(object.latestHeight) ? Height.fromJSON(object.latestHeight) : undefined,
      proofSpecs: Array.isArray(object?.proofSpecs) ? object.proofSpecs.map((e: any) => ProofSpec.fromJSON(e)) : [],
      upgradePath: Array.isArray(object?.upgradePath) ? object.upgradePath.map((e: any) => String(e)) : [],
      allowUpdateAfterExpiry: isSet(object.allowUpdateAfterExpiry) ? Boolean(object.allowUpdateAfterExpiry) : false,
      allowUpdateAfterMisbehaviour: isSet(object.allowUpdateAfterMisbehaviour) ? Boolean(object.allowUpdateAfterMisbehaviour) : false
    };
  },

  toJSON(message: ClientState): unknown {
    const obj: any = {};
    message.chainId !== undefined && (obj.chainId = message.chainId);
    message.trustLevel !== undefined && (obj.trustLevel = message.trustLevel ? Fraction.toJSON(message.trustLevel) : undefined);
    message.trustingPeriod !== undefined && (obj.trustingPeriod = message.trustingPeriod);
    message.unbondingPeriod !== undefined && (obj.unbondingPeriod = message.unbondingPeriod);
    message.maxClockDrift !== undefined && (obj.maxClockDrift = message.maxClockDrift);
    message.frozenHeight !== undefined && (obj.frozenHeight = message.frozenHeight ? Height.toJSON(message.frozenHeight) : undefined);
    message.latestHeight !== undefined && (obj.latestHeight = message.latestHeight ? Height.toJSON(message.latestHeight) : undefined);

    if (message.proofSpecs) {
      obj.proofSpecs = message.proofSpecs.map(e => e ? ProofSpec.toJSON(e) : undefined);
    } else {
      obj.proofSpecs = [];
    }

    if (message.upgradePath) {
      obj.upgradePath = message.upgradePath.map(e => e);
    } else {
      obj.upgradePath = [];
    }

    message.allowUpdateAfterExpiry !== undefined && (obj.allowUpdateAfterExpiry = message.allowUpdateAfterExpiry);
    message.allowUpdateAfterMisbehaviour !== undefined && (obj.allowUpdateAfterMisbehaviour = message.allowUpdateAfterMisbehaviour);
    return obj;
  },

  fromPartial(object: DeepPartial<ClientState>): ClientState {
    const message = createBaseClientState();
    message.chainId = object.chainId ?? "";
    message.trustLevel = object.trustLevel !== undefined && object.trustLevel !== null ? Fraction.fromPartial(object.trustLevel) : undefined;
    message.trustingPeriod = object.trustingPeriod ?? undefined;
    message.unbondingPeriod = object.unbondingPeriod ?? undefined;
    message.maxClockDrift = object.maxClockDrift ?? undefined;
    message.frozenHeight = object.frozenHeight !== undefined && object.frozenHeight !== null ? Height.fromPartial(object.frozenHeight) : undefined;
    message.latestHeight = object.latestHeight !== undefined && object.latestHeight !== null ? Height.fromPartial(object.latestHeight) : undefined;
    message.proofSpecs = object.proofSpecs?.map(e => ProofSpec.fromPartial(e)) || [];
    message.upgradePath = object.upgradePath?.map(e => e) || [];
    message.allowUpdateAfterExpiry = object.allowUpdateAfterExpiry ?? false;
    message.allowUpdateAfterMisbehaviour = object.allowUpdateAfterMisbehaviour ?? false;
    return message;
  },

  fromSDK(object: ClientStateSDKType): ClientState {
    return {
      chainId: object?.chain_id,
      trustLevel: object.trust_level ? Fraction.fromSDK(object.trust_level) : undefined,
      trustingPeriod: object.trusting_period ? Duration.fromSDK(object.trusting_period) : undefined,
      unbondingPeriod: object.unbonding_period ? Duration.fromSDK(object.unbonding_period) : undefined,
      maxClockDrift: object.max_clock_drift ? Duration.fromSDK(object.max_clock_drift) : undefined,
      frozenHeight: object.frozen_height ? Height.fromSDK(object.frozen_height) : undefined,
      latestHeight: object.latest_height ? Height.fromSDK(object.latest_height) : undefined,
      proofSpecs: Array.isArray(object?.proof_specs) ? object.proof_specs.map((e: any) => ProofSpec.fromSDK(e)) : [],
      upgradePath: Array.isArray(object?.upgrade_path) ? object.upgrade_path.map((e: any) => e) : [],
      allowUpdateAfterExpiry: object?.allow_update_after_expiry,
      allowUpdateAfterMisbehaviour: object?.allow_update_after_misbehaviour
    };
  },

  toSDK(message: ClientState): ClientStateSDKType {
    const obj: any = {};
    obj.chain_id = message.chainId;
    message.trustLevel !== undefined && (obj.trust_level = message.trustLevel ? Fraction.toSDK(message.trustLevel) : undefined);
    message.trustingPeriod !== undefined && (obj.trusting_period = message.trustingPeriod ? Duration.toSDK(message.trustingPeriod) : undefined);
    message.unbondingPeriod !== undefined && (obj.unbonding_period = message.unbondingPeriod ? Duration.toSDK(message.unbondingPeriod) : undefined);
    message.maxClockDrift !== undefined && (obj.max_clock_drift = message.maxClockDrift ? Duration.toSDK(message.maxClockDrift) : undefined);
    message.frozenHeight !== undefined && (obj.frozen_height = message.frozenHeight ? Height.toSDK(message.frozenHeight) : undefined);
    message.latestHeight !== undefined && (obj.latest_height = message.latestHeight ? Height.toSDK(message.latestHeight) : undefined);

    if (message.proofSpecs) {
      obj.proof_specs = message.proofSpecs.map(e => e ? ProofSpec.toSDK(e) : undefined);
    } else {
      obj.proof_specs = [];
    }

    if (message.upgradePath) {
      obj.upgrade_path = message.upgradePath.map(e => e);
    } else {
      obj.upgrade_path = [];
    }

    obj.allow_update_after_expiry = message.allowUpdateAfterExpiry;
    obj.allow_update_after_misbehaviour = message.allowUpdateAfterMisbehaviour;
    return obj;
  }

};"
`;

exports[`ibc/lightclients/tendermint/v1/tendermint string 3`] = `
"export interface ClientStateAminoType extends AminoMsg {
  type: "cosmos-sdk/ClientState";
  value: {
    chain_id: string;
    trust_level: {
      numerator: string;
      denominator: string;
    };
    trusting_period: string;
    unbonding_period: string;
    max_clock_drift: string;
    frozen_height: AminoHeight;
    latest_height: AminoHeight;
    proof_specs: {
      leaf_spec: {
        hash: number;
        prehash_key: number;
        prehash_value: number;
        length: number;
        prefix: Uint8Array;
      };
      inner_spec: {
        child_order: number[];
        child_size: number;
        min_prefix_length: number;
        max_prefix_length: number;
        empty_child: Uint8Array;
        hash: number;
      };
      max_depth: number;
      min_depth: number;
    }[];
    upgrade_path: string[];
    allow_update_after_expiry: boolean;
    allow_update_after_misbehaviour: boolean;
  };
}"
`;

exports[`ibc/lightclients/tendermint/v1/tendermint string 4`] = `
"export const AminoConverter = {
  "/ibc.lightclients.tendermint.v1.ClientState": {
    aminoType: "cosmos-sdk/ClientState",
    toAmino: ({
      chainId,
      trustLevel,
      trustingPeriod,
      unbondingPeriod,
      maxClockDrift,
      frozenHeight,
      latestHeight,
      proofSpecs,
      upgradePath,
      allowUpdateAfterExpiry,
      allowUpdateAfterMisbehaviour
    }: ClientState): ClientStateAminoType["value"] => {
      return {
        chain_id: chainId,
        trust_level: {
          numerator: trustLevel.numerator.toString(),
          denominator: trustLevel.denominator.toString()
        },
        trusting_period: (trustingPeriod * 1_000_000_000).toString(),
        unbonding_period: (unbondingPeriod * 1_000_000_000).toString(),
        max_clock_drift: (maxClockDrift * 1_000_000_000).toString(),
        frozen_height: frozenHeight ? {
          revision_height: omitDefault(frozenHeight.revisionHeight)?.toString(),
          revision_number: omitDefault(frozenHeight.revisionNumber)?.toString()
        } : {},
        latest_height: latestHeight ? {
          revision_height: omitDefault(latestHeight.revisionHeight)?.toString(),
          revision_number: omitDefault(latestHeight.revisionNumber)?.toString()
        } : {},
        proof_specs: proofSpecs.map(el0 => ({
          leaf_spec: {
            hash: el0.leafSpec.hash,
            prehash_key: el0.leafSpec.prehashKey,
            prehash_value: el0.leafSpec.prehashValue,
            length: el0.leafSpec.length,
            prefix: el0.leafSpec.prefix
          },
          inner_spec: {
            child_order: el0.innerSpec.childOrder,
            child_size: el0.innerSpec.childSize,
            min_prefix_length: el0.innerSpec.minPrefixLength,
            max_prefix_length: el0.innerSpec.maxPrefixLength,
            empty_child: el0.innerSpec.emptyChild,
            hash: el0.innerSpec.hash
          },
          max_depth: el0.maxDepth,
          min_depth: el0.minDepth
        })),
        upgrade_path: upgradePath,
        allow_update_after_expiry: allowUpdateAfterExpiry,
        allow_update_after_misbehaviour: allowUpdateAfterMisbehaviour
      };
    },
    fromAmino: ({
      chain_id,
      trust_level,
      trusting_period,
      unbonding_period,
      max_clock_drift,
      frozen_height,
      latest_height,
      proof_specs,
      upgrade_path,
      allow_update_after_expiry,
      allow_update_after_misbehaviour
    }: ClientStateAminoType["value"]): ClientState => {
      return {
        chainId: chain_id,
        trustLevel: {
          numerator: Long.fromString(trust_level.numerator),
          denominator: Long.fromString(trust_level.denominator)
        },
        trustingPeriod: {
          seconds: Long.fromNumber(Math.floor(parseInt(trusting_period) / 1_000_000_000)),
          nanos: parseInt(trusting_period) % 1_000_000_000
        },
        unbondingPeriod: {
          seconds: Long.fromNumber(Math.floor(parseInt(unbonding_period) / 1_000_000_000)),
          nanos: parseInt(unbonding_period) % 1_000_000_000
        },
        maxClockDrift: {
          seconds: Long.fromNumber(Math.floor(parseInt(max_clock_drift) / 1_000_000_000)),
          nanos: parseInt(max_clock_drift) % 1_000_000_000
        },
        frozenHeight: frozen_height ? {
          revisionHeight: Long.fromString(frozen_height.revision_height || "0", true),
          revisionNumber: Long.fromString(frozen_height.revision_number || "0", true)
        } : undefined,
        latestHeight: latest_height ? {
          revisionHeight: Long.fromString(latest_height.revision_height || "0", true),
          revisionNumber: Long.fromString(latest_height.revision_number || "0", true)
        } : undefined,
        proofSpecs: proof_specs.map(el0 => ({
          leafSpec: {
            hash: hashOpFromJSON(el0.leaf_spec.hash),
            prehashKey: hashOpFromJSON(el0.leaf_spec.prehash_key),
            prehashValue: hashOpFromJSON(el0.leaf_spec.prehash_value),
            length: lengthOpFromJSON(el0.leaf_spec.length),
            prefix: el0.leaf_spec.prefix
          },
          innerSpec: {
            childOrder: el0.inner_spec.child_order,
            childSize: el0.inner_spec.child_size,
            minPrefixLength: el0.inner_spec.min_prefix_length,
            maxPrefixLength: el0.inner_spec.max_prefix_length,
            emptyChild: el0.inner_spec.empty_child,
            hash: hashOpFromJSON(el0.inner_spec.hash)
          },
          maxDepth: el0.max_depth,
          minDepth: el0.min_depth
        })),
        upgradePath: upgrade_path,
        allowUpdateAfterExpiry: allow_update_after_expiry,
        allowUpdateAfterMisbehaviour: allow_update_after_misbehaviour
      };
    }
  }
};"
`;
